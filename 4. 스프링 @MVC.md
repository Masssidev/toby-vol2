# 스프링 @MVC
### @RequestMapping 핸들러 매핑
@MVC의 가장 큰 특징은 핸들러 매핑과 핸들러 어댑터의 대상이 오브젝트가 아니라 메소드라는 점이다.
#### 클래스/메소드 결합 매핑정보
DefaultAnnotationHandlerMapping의 핵심은 매핑정보로 @RequestMapping 애노테이션을 활용한다는 점이다. 그런데 @RequestMapping은 타입 레벨뿐 아니라 메소드 레벨도 붙일 수 있다. 스프링은 이 두 가지 위치에 붙은 @RequestMapping의 정보를 결합해서 최종 매핑벙보를 생성한다. 
##### @RequestMapping 애노테이션 엘리먼트
* String[] value(): URL 패턴
    * URL 패턴 및 와일드카드
      * ```@RequestMapping("/hello"), @RequestMapping("/main*"), @RequestMapping("/view.*"), @RequestMapping("/admin/**/user")```
    * path variable
      * ```@RequestMapping("/user/{userid}")```
    * 디폴트 접미어 패턴
      * ```@RequestMapping({"/hello", "/hello/", "/hello.*"})```
* RequestMethod[] method(): HTTP 요청 메소드
    * RequestMethod는 HTTP 메소드를 정의한 이늄(enum)이다. GET, HEAD, POST, PUT, DELETE, OPTIONS, TRACE 7개의 HTTP 메소드가 정의되어 있다. @RequestMapping에 HTTP 요청 메소드를 추가해주면 같은 URL이라고 하더라도 요청 메소드에 따라 다른 메소드에 매핑해줄 수 있다.
      * ```@RequestMapping(value="/user/add", method=RequestMethod.GET), @RequestMapping(value="/user/add", method=RequestMethod.POST)```
* String[] params(): 요청 파라미터
    * 요청의 파라미터와 그 값을 비교해서 매핑해준다. 같은 URL을 사용하더라도 HTTP 요청 파라미터에 따라 별도의 작업을 해주고 싶을 때 사용한다.
      * ```@RequestMapping(value="/user/edit", params="type=admin"), @RequestMapping(value="/user/edit", params="type=member")```
    * 특정 파라미터가 존재하지 않아야 한다는 조건을 지정할 수도 있다.
      * ```@RequestMapping(value="/user/edit", params="!type")```
    * params도 배열로 선언되어 있으므로 하나 이상을 지정할 수 있다.
* String[] headers(): HTTP 헤더
    * HTTP 헤더정보. 자주 사용되지는 않는다.
      * ```@RequestMapping(value="/view", headers="content-type=text/*")```
##### 타입 레벨 매핑과 메소드 레벨 매핑의 결합
타입(클래스와 인터페이스) 레벨에 붙는 @RequestMapping은 타입 내의 모든 매핑용 메소드의 공통 조건을 지정할 때 사용한다. 그리고 메소드 레벨에서 조건을 세분화해주면 된다. 메소드 레벨의 매핑은 클래스 레벨의 매핑을 상속받는다고 보면 된다.
##### 메소드 레벨 단독 매핑
메소드 레벨의 매핑조건에 공통점이 없는 경우라면 타입 레벨에서는 조건을 주지 않고 메소드 레벨에서 독립적으로 매핑정보를 지정할 수도 있다. 타입 레벨에는 조건이 없는 @RequestMapping을 붙여두면 된다. 컨트롤러 클래스에 @Controller 애노테이션을 붙여서 빈 자동스캔 방식으로 등록되게 했다면, 이때는 클래스 레벨의 @RequestMapping을 생략할 수도 있다.
##### 타입 레벨 단독 매핑
@RequestMapping을 타입 레벨에 단독으로 사용해서 다른 타입 컨트롤러에 대한 매핑을 위해 사용할 수도 있다.

클래스 레벨의 URL 패턴이 ```/*```로 끝나는 경우에는 메소드 레벨의 URL 패턴으로 메소드 이름이 사용되게 할 수 있다.
```
@RequestMapping("/user/*")
public class UserController {
  @RequestMapping public String add(...) { }
  @RequestMapping public String edit(...) { }
}
```
#### 타입 상속과 매핑
@RequestMapping이 적용된 클래스를 상속해서 컨트롤러로 사용하는 경우 서브클래스에서 @RequestMapping을 재정의하면 슈퍼클래스의 정보는 무시된다. 서브클래스에서 재정의하지 않는 한 상속을 통해서도 유지된다.
##### 매핑정보 상속의 종류
* 상위 타입과 메소드의 @RequestMapping 상속
    * 슈퍼클래스에만 @RequestMapping을 적용하고 이를 그대로 상속한 서브클래스에는 아무런 @RequestMapping을 사용하지 않았을 경우 슈퍼클래스에 정의된 모든 매핑정보를 그대로 서브클래스가 물려받는다.
* 상위 타입의 @RequestMapping과 하위 타입 메소드의 @RequestMapping 결합
    * 슈퍼클래스에는 타입에만 @RequestMapping이 선언되어 있고, 서브클래스에는 타입 레벨에는 아무 매핑정보가 없고 메소드에만 @RequestMapping이 있는 경우 이때도 슈퍼클래스의 타입 레벨 @RequestMapping이 상속되어 서브클래스의 타입 레벨에 @RequestMapping이 정의되어 있는 것처럼 각 메소드의 매핑정보가 결합돼서 최종적인 메소드 레벨의 매핑조건을 만들어낸다.
* 상위 타입 메소드의 @RequestMapping과 하위 타입의 @RequestMapping 결합
    * 슈퍼클래스에는 메소드에만 @RequestMapping이 있고, 서브클래스에는 반대로 클래스 레벨에 @RequestMapping이 부여된 경우 이때도 마찬가지로 @RequestMapping 정보가 그대로 상속된 후에 결합된다.
* 하위 타입과 메소드의 @RequestMapping 재정의
    * 상속 또는 구현을 통해 만들어진 하위 타입에 @RequestMapping을 부여하면 상위 타입에서 지정한 @RequestMapping 매핑정보를 대체해서 적용된다. @RequestMapping은 상속 또는 구현을 통해 하위 타입에서 재정의할 수 있다.
* 서브클래스 메소드의 URL 패턴 없는 @RequestMapping 재정의
    * 클래스 상속에서 오버라이드한 하위 메소드에 한해서는 URL 조건이 없는 @RequestMapping을 붙였을 경우에 상위 메소드의 @RequestMapping의 URL 조건이 그대로 상속된다.
##### 제네릭스와 매핑정보 상속을 이용한 컨트롤러 작성
제네릭스를 활용해서 상위 타입에는 타입 파라미터와 메소드 레벨의 공통 매핑정보를 지정해놓고, 이를 상속받는 개별 컨트롤러에는 구체적인 타입과 클래스 레벨의 기준 매핑정보를 지정해주는 기법을 사용할 수 있다.
<hr/>

### @Controller
@Controller에서는 컨트롤러 역할을 담당하는 메소드의 파라미터 개수와 타입, 리턴 타입 등을 자유롭게 결정할 수 있다. 여기에 @RequestMapping을 비롯한 다양한 애노테이션을 메소드나 파라미터에 적용해서 컨트롤러 로직에 대한 추가적인 정보를 제공할 수도 있다. 

스프링은 메소드의 파라미터와 리턴 값이 어떻게 선언됐는지 살펴보고, 이를 이용해 적절한 파라미터 값을 준비해서 호출해준다. 리턴 값도 타입에 따라 적절한 방식으로 사용한다. 따라서 @Controller에서 허용되는 파라미터와 리턴 값의 종류를 알고 있다면 필요한 정보만을 주고받을 수 있는 최적화된 메소드를 설계할 수 있다.
#### 메소드 파라미터의 종류
* HttpServletRequest, HttpServletResponse
* HttpSession
* WebRequest, NativeWebRequest
* Locale
* InputStream, Reader
* OutputStream, Writer
* @PathVariable
* @RequestParam
* @CookieValue
* @RequestHeader
* Map, Model, ModelMap
* @ModelAttribute
* Errors, BindingResult
* SessionStatus
* @RequestBody
* @Value
* @Valid
#### 리턴 타입의 종류
##### 자동 추가 모델 모브젝트와 자동생성 뷰 이름
* @ModelAttribute 모델 오브젝트 또는 커맨드 오브젝트
* Map, Model, ModelMap 파라미터
* @ModelAttribute 메소드
* BindingResult
##### 메소드 리턴 타입 종류
* ModelAndView
* String
* void
* 모델 오브젝트
* Map/Model/ModelMap
* View
* @ResponseBody
#### @SessionAttributes와 SessionStatus
도메인 오브젝트를 사용해 **수정** 폼을 처리할 때 발생하는 문제들을 해결하는 방법
* 히든 필드
   * 브라우저 화면에는 보이지 않지만 HTML 소스를 열어보면 그 내용과 필드 이름까지 쉽게 알아낼 수 있어 보안에 심각한 문제를 일으킨다.
* DB 재조회(DB에서 조회 후 수정할 내용을 덮어 씌운 후 업데이트)
   * DB의 부담이 증가한다.
* 계층 사이의 강한 결합(수정할 필드들만을 위한 메소드와 계층을 준비)
   * 코드를 재사용하기가 힘들다.
> 위의 세 방법은 단점이 많다. 따라서 스프링의 해결책을 사용하자.
##### @SessionAttributes
* @SessionAttributes 애노테이션을 클래스 레벨에 부여하고 폼의 정보를 담을 모델 이름을 넣어준다.
   * 컨트롤러 메소드가 생성하는 모델 정보 중에서 @SessionAttributes에 지정한 이름과 동일한 것이 있다면 이를 세션에 저장해준다.
   * @ModelAttribute가 지정된 파라미터가 있을 때 이 파라미터에 전달해줄 오브젝트를 세션에서 가져온다.
* @SessionAttributes의 설정은 클래스의 모든 메소드에 적용된다.
##### SessionStatus
* @SessionAttributes를 사용할 때는 더 이상 필요 없는 세션 애트리뷰트를 코드로 제거해줘야 한다.
* 작업을 마무리하는 코드에서는 작업을 성공적으로 마쳤다면 SessionStatus 오브젝트의 setComplete() 메소드를 호출해서 세션에 저장해뒀던 오브젝트를 제거해줘야 한다.
##### 등록 폼을 위한 @SessionAttributes 사용
* 복잡한 도메인 오브젝트의 경우 미리 초기화 해두거나, 사용자의 입력을 돕기 위해 디폴트 값을 보여주는 경우, 초기화된 오브젝트를 세션에 저장해두고 사용해야 한다. 등록 폼의 입력 값에서도 잘못된 것이 있으면 다시 폼을 띄워서 재입력을 요구해야 한다.
* 등록과 수정 화면에 상관없이 폼을 출력할 때 폼의 내용을 담은 모델 오브젝트를 필요로 하기에, 스프링의 폼 태그를 사용하기 위해 @SessionAttributes를 이용해 모델 오브젝트를 저장했다가 다시 사용하는 게 좋다.
<hr/>

### 모델 바인딩과 검증
컨트롤러 메소드에 @ModelAttribute가 지정된 파라미터를 @Controller 메소드에 추가하면 세 가지 작업이 자동으로 진행된다.
1. 파라미터 타입의 오브젝트를 만든다. @ModelAttribute User user라는 파라미터 선언이 있다면 User 타입의 오브젝트를 생성한다. 이를 위해 디폴트 생성자가 반드시 필요하다. @SessionAttributes에 의해 세션에 저장된 모델 오브젝트가 있다면, 새로운 오브젝트를 생성하는 대신 세션에 저장되어 있는 오브젝트를 가져온다.
2. 준비된 모델 오브젝트의 프로퍼티에 웹 파라미터를 바인딩해준다. 스프링에 준비되어 있는 기본 프로퍼티 에디터를 이용해서 HTTP 파라미터 값을 모델의 프로퍼티 타입에 맞게 전환한다. 전환이 불가능한 경우라면, BindingResult 오브젝트 안에 바인딩 오류를 저장해서 컨트롤러로 넘겨주거나 예외를 발생시킨다.
3. 모델의 값을 검증한다. 바인딩 단계에서 타입에 대한 검증은 끝났지만, 그 외의 검증할 내용이 있다면 적절한 검증기를 등록해서 모델의 내용을 검증할 수 있다. 스프링에서는 컨트롤러 로직과 검증 로직을 분리할 수 있다.

스프링에서 바인딩이라고 말할 때는 오브젝트의 프로퍼티에 값을 넣는 것을 말한다. 반대로 프로퍼티로부터 값을 읽어오는 경우도 있다. 스프링은 바인딩 과정에서 변환 작업을 위해 기본적으로 두 가지 종류의 API를 제공한다.
#### 1. PropertyEditor
##### 디폴트 프로퍼티 에디터
바인딩 과정에서는 변환할 파라미터 또는 모델 프로퍼티의 타입에 맞는 프로퍼티 에디터가 자동으로 선정돼서 사용된다. 기본적으로 스프링이 제공하는 프로퍼티 에디터의 종류와 지원 타입이 어떤 것인지 기억해두고 활용하면 된다.
##### 커스텀 프로퍼티 에디터
스프링이 지원하지 않는 타입을 파라미터로 사용한다면, 직접 프로퍼티 에디터를 만들어서 적용할 수 있다. PropertyEditor 인터페이스를 직접 구현하기보다는 기본 구현이 되어 있는 PropertyEditorSupport 클래스를 상속해서 필요한 메소드만 오버라이드해주는 편이 낫다.
##### @InitBinder
@InitBinder가 붙은 initBinder() 메소드는 메소드 파라미터를 바인딩하기 전에 자동으로 호출된다. 그래서 스프링의 디폴트 프로퍼티 에디터만 갖고 있는 WebDataBinder에 커스텀 프로퍼티 에디터를 추가할 수 있는 기회를 제공해준다.
* WebDataBinder에 커스텀 프로퍼티 에디터를 등록하는 방법
   * 특정 타입에 무조건 적용되는 프로퍼티 에디터 등록
   * 특정 이름의 프로퍼티에만 적용되는 프로퍼티 에디터 등록
> 커스텀 프로퍼티 에디터가 디폴트 프로퍼티 에디터보다 우선순위가 높다.
##### WebBindingInitializer
모든 컨트롤러에 적용해도 될 만큼 많은 곳에서 필요한 프로퍼티 에디터라면 WebBindingInitializer 인터페이스를 구현해서 한 번에 모든 컨트롤러에 적용하는 편이 좋다.
##### 프로토타입 빈 프로퍼티 에디터
프로퍼티 바인딩을 할 때마다 매번 새로운 프로퍼티 에디터 오브젝트를 새로 만드는 대신 프로퍼티 에디터를 싱글톤 빈으로 등록해두고 이를 공유해서 쓸 수는 없다. 프로퍼티 에디터는 멀티스레드 환경에서 싱글톤으로 만들어 여러 오브젝트가 공유해서 사용하면 안 된다. 자칫하면 다른 스레드에서 변환하는 값으로 덮어쓰일 수 있다. 그래서 바인딩 할 때마다 매번 새로운 프로퍼티 에디터 오브젝트를 만들어 사용한다.

프로퍼티 에디터가 다른 스프링 빈을 참조해야 한다면 프로퍼티 에디터를 빈으로 등록해야 한다. 하지만 프로퍼티 에디터는 싱글톤 빈으로 등록해서 공유할 수 없으니 프로토타입 스코프의 빈으로 만들어져야 한다. 

폼의 파라미터가 모델의 프로퍼티에 바인딩될 때 단순 타입이 아닌 경우 바인딩하는 방법
* 별도의 codeid 필드로 바인딩
   * 매번 컨트롤러나 서비스 계층 코드에서 id에 해당하는 임시 프로퍼티 갑을 이용해서 도메인 오브젝트 타입의 프로퍼티를 설정해주는 작업을 해야 한다.
* 모조 오브젝트 프로퍼티 에디터
   * id만 가진 오브젝트는 **모조 오브젝트**라고 하고, 이런 오브젝트를 만드는 프로퍼티 에디터를 **모조 프로퍼티 에디터**라고 부른다.
   * 위험성은 있지만 매우 유용한 방법이다.
* 프로토타입 도메인 오브젝트 프로퍼티 에디터
   * DB에서 Code 오브젝트를 새로 읽어와야하기 때문에 미미하지만 성능에 부담을 준다. 하지만 캐시를 사용하면 된다.
#### 2. Converter와 Formatter
PropertyEditor는 매번 바인딩을 할 때마다 새로운 오브젝트를 만들어야 한다. 그래서 스프링 3.0에는 PropertyEditor를 대신할 수 있는 새로운 타입 변환 API가 도입됐다. 바로 Converter 인터페이스다. PropertyEditor와 달리 Converter는 변환 과정에서 메소드가 한 번만 호출된다. 그래서 멀티스레드 환경에서 안전하게 공유해서 쓸 수 있다.
##### Converter
문자열과 오브젝트 사이의 양방향 변환 기능을 제공하는 PropertyEditor와 다르게 Converter 메소드는 소스 타입에서 타깃 타입으로의 단방향 변환만 지원한다. 물론 소스와 타깃을 바꿔서 컨버터를 하나 더 만들면 양방향 변환이 가능해진다. Converter는 소스와 타깃의 타입을 임의로 지정할 수 있다. 따라서 범용적으로 사용할 수 있는 컨버터를 정의할 수 있다.
##### ConversionService
ConversionService는 여러 종류의 컨버터를 이용해서 하나 이상의 타입 변환 서비스를 제공해주는 오브젝트를 만들 때 사용하는 인터페이스다. 보통 ConversionService를 구현한 GenericConversionService 클래스를 빈으로 등록해서 사용하면 된다. GenericConversionService는 스프링의 다양한 타입 변환 기능을 가진 오브젝트를 등록할 수 있는 ConverterRegistry 인터페이스도 구현하고 있다. 따라서 GenericConverter를 이용하면 단순히 타입의 종류뿐 아니라 부가적인 정보를 활용한 변환 로직을 작성할 수 있다. ConverterFactory는 제네릭스를 활용해서 특정 타입에 대한 컨버터 오브젝트를 만들어주는 팩토리를 구현할 때 사용한다.
* @MVC  컨트롤러의 메소드 파라미터를 위해 사용하는 WebDataBinder에 GenericConversionService를 설정하는 방법
1. @InitBinder를 통한 수동 등록
2. ConfigurableWebBindingInitializer를 이용한 일괄 등록
##### Formatter와 FormattingConversionService
포맷터는 스프트링 타입의 폼 필드 정보와 컨트롤러 메소드의 파라미터 사이에 양방향으로 적용할 수 있도록 두 개의 변환 메소드를 갖고 있다. Formatter는 그 자체로 Converter와 같이 스프링이 기본적으로 지원하는 범용적인 타입 변환 API가 아니다. 따라서 Formatter 구현 오브젝트를 GenericConverter 타입으로 포장해서 등록해주는 기능을 가진 FormattingConversionService를 통해서만 적용될 수 있다.
* FormattingConversionServiceFactoryBean을 사용했을 때 자동으로 등록되는 포맷터
   * @NumberFormat
   * @DateTimeFormat
##### 바인딩 기술의 적용 우선순위와 활용 전략
* 사용자 정의 타입의 바인딩을 위한 일괄 적용: Converter
* 필드와 메소드 파라미터, 애노테이션 등의 메타정보를 활용하는 조건부 변환 기능: ConditionalGenericConverter
* 애노테이션 정보를 활용한 HTTP 요청과 모델 필드 바인딩: AnnotationFormatterFactory와 Formatter
* 특정 필드에만 적용되는 변환 기능: PropertyEditor
> 필드를 지정해서 제한적으로 변환 기능을 적용하는 경우를 제외하면, 프로퍼티 에디터보다는 안전하고 장점이 많은 컨버터나 포맷터 등으로 대체하는 것이 좋다.
#### WebDataBinder 설정 항목
