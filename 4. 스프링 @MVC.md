# 스프링 @MVC
### @RequestMapping 핸들러 매핑
@MVC의 가장 큰 특징은 핸들러 매핑과 핸들러 어댑터의 대상이 오브젝트가 아니라 메소드라는 점이다.
#### 클래스/메소드 결합 매핑정보
DefaultAnnotationHandlerMapping의 핵심은 매핑정보로 @RequestMapping 애노테이션을 활용한다는 점이다. 그런데 @RequestMapping은 타입 레벨뿐 아니라 메소드 레벨도 붙일 수 있다. 스프링은 이 두 가지 위치에 붙은 @RequestMapping의 정보를 결합해서 최종 매핑벙보를 생성한다. 
##### @RequestMapping 애노테이션 엘리먼트
* String[] value(): URL 패턴
    * URL 패턴 및 와일드카드
      * ```@RequestMapping("/hello"), @RequestMapping("/main*"), @RequestMapping("/view.*"), @RequestMapping("/admin/**/user")```
    * path variable
      * ```@RequestMapping("/user/{userid}")```
    * 디폴트 접미어 패턴
      * ```@RequestMapping({"/hello", "/hello/", "/hello.*"})```
* RequestMethod[] method(): HTTP 요청 메소드
    * RequestMethod는 HTTP 메소드를 정의한 이늄(enum)이다. GET, HEAD, POST, PUT, DELETE, OPTIONS, TRACE 7개의 HTTP 메소드가 정의되어 있다. @RequestMapping에 HTTP 요청 메소드를 추가해주면 같은 URL이라고 하더라도 요청 메소드에 따라 다른 메소드에 매핑해줄 수 있다.
      * ```@RequestMapping(value="/user/add", method=RequestMethod.GET), @RequestMapping(value="/user/add", method=RequestMethod.POST)```
* String[] params(): 요청 파라미터
    * 요청의 파라미터와 그 값을 비교해서 매핑해준다. 같은 URL을 사용하더라도 HTTP 요청 파라미터에 따라 별도의 작업을 해주고 싶을 때 사용한다.
      * ```@RequestMapping(value="/user/edit", params="type=admin"), @RequestMapping(value="/user/edit", params="type=member")```
    * 특정 파라미터가 존재하지 않아야 한다는 조건을 지정할 수도 있다.
      * ```@RequestMapping(value="/user/edit", params="!type")```
    * params도 배열로 선언되어 있으므로 하나 이상을 지정할 수 있다.
* String[] headers(): HTTP 헤더
    * HTTP 헤더정보. 자주 사용되지는 않는다.
      * ```@RequestMapping(value="/view", headers="content-type=text/*")```
##### 타입 레벨 매핑과 메소드 레벨 매핑의 결합
타입(클래스와 인터페이스) 레벨에 붙는 @RequestMapping은 타입 내의 모든 매핑용 메소드의 공통 조건을 지정할 때 사용한다. 그리고 메소드 레벨에서 조건을 세분화해주면 된다. 메소드 레벨의 매핑은 클래스 레벨의 매핑을 상속받는다고 보면 된다.
##### 메소드 레벨 단독 매핑
메소드 레벨의 매핑조건에 공통점이 없는 경우라면 타입 레벨에서는 조건을 주지 않고 메소드 레벨에서 독립적으로 매핑정보를 지정할 수도 있다. 타입 레벨에는 조건이 없는 @RequestMapping을 붙여두면 된다. 컨트롤러 클래스에 @Controller 애노테이션을 붙여서 빈 자동스캔 방식으로 등록되게 했다면, 이때는 클래스 레벨의 @RequestMapping을 생략할 수도 있다.
##### 타입 레벨 단독 매핑
@RequestMapping을 타입 레벨에 단독으로 사용해서 다른 타입 컨트롤러에 대한 매핑을 위해 사용할 수도 있다.

클래스 레벨의 URL 패턴이 ```/*```로 끝나는 경우에는 메소드 레벨의 URL 패턴으로 메소드 이름이 사용되게 할 수 있다.
```
@RequestMapping("/user/*")
public class UserController {
  @RequestMapping public String add(...) { }
  @RequestMapping public String edit(...) { }
}
```
#### 타입 상속과 매핑
@RequestMapping이 적용된 클래스를 상속해서 컨트롤러로 사용하는 경우 서브클래스에서 @RequestMapping을 재정의하면 슈퍼클래스의 정보는 무시된다. 서브클래스에서 재정의하지 않는 한 상속을 통해서도 유지된다.
##### 매핑정보 상속의 종류
* 상위 타입과 메소드의 @RequestMapping 상속
    * 슈퍼클래스에만 @RequestMapping을 적용하고 이를 그대로 상속한 서브클래스에는 아무런 @RequestMapping을 사용하지 않았을 경우 슈퍼클래스에 정의된 모든 매핑정보를 그대로 서브클래스가 물려받는다.
* 상위 타입의 @RequestMapping과 하위 타입 메소드의 @RequestMapping 결합
    * 슈퍼클래스에는 타입에만 @RequestMapping이 선언되어 있고, 서브클래스에는 타입 레벨에는 아무 매핑정보가 없고 메소드에만 @RequestMapping이 있는 경우 이때도 슈퍼클래스의 타입 레벨 @RequestMapping이 상속되어 서브클래스의 타입 레벨에 @RequestMapping이 정의되어 있는 것처럼 각 메소드의 매핑정보가 결합돼서 최종적인 메소드 레벨의 매핑조건을 만들어낸다.
* 상위 타입 메소드의 @RequestMapping과 하위 타입의 @RequestMapping 결합
    * 슈퍼클래스에는 메소드에만 @RequestMapping이 있고, 서브클래스에는 반대로 클래스 레벨에 @RequestMapping이 부여된 경우 이때도 마찬가지로 @RequestMapping 정보가 그대로 상속된 후에 결합된다.
* 하위 타입과 메소드의 @RequestMapping 재정의
    * 상속 또는 구현을 통해 만들어진 하위 타입에 @RequestMapping을 부여하면 상위 타입에서 지정한 @RequestMapping 매핑정보를 대체해서 적용된다. @RequestMapping은 상속 또는 구현을 통해 하위 타입에서 재정의할 수 있다.
* 서브클래스 메소드의 URL 패턴 없는 @RequestMapping 재정의
    * 클래스 상속에서 오버라이드한 하위 메소드에 한해서는 URL 조건이 없는 @RequestMapping을 붙였을 경우에 상위 메소드의 @RequestMapping의 URL 조건이 그대로 상속된다.
##### 제네릭스와 매핑정보 상속을 이용한 컨트롤러 작성
제네릭스를 활용해서 상위 타입에는 타입 파라미터와 메소드 레벨의 공통 매핑정보를 지정해놓고, 이를 상속받는 개별 컨트롤러에는 구체적인 타입과 클래스 레벨의 기준 매핑정보를 지정해주는 기법을 사용할 수 있다.
<hr/>

### @Controller
@Controller에서는 컨트롤러 역할을 담당하는 메소드의 파라미터 개수와 타입, 리턴 타입 등을 자유롭게 결정할 수 있다. 여기에 @RequestMapping을 비롯한 다양한 애노테이션을 메소드나 파라미터에 적용해서 컨트롤러 로직에 대한 추가적인 정보를 제공할 수도 있다. 

스프링은 메소드의 파라미터와 리턴 값이 어떻게 선언됐는지 살펴보고, 이를 이용해 적절한 파라미터 값을 준비해서 호출해준다. 리턴 값도 타입에 따라 적절한 방식으로 사용한다. 따라서 @Controller에서 허용되는 파라미터와 리턴 값의 종류를 알고 있다면 필요한 정보만을 주고받을 수 있는 최적화된 메소드를 설계할 수 있다.
#### 메소드 파라미터의 종류
* HttpServletRequest, HttpServletResponse
* HttpSession
* WebRequest, NativeWebRequest
* Locale
* InputStream, Reader
* OutputStream, Writer
* @PathVariable
* @RequestParam
* @CookieValue
* @RequestHeader
* Map, Model, ModelMap
* @ModelAttribute
* Errors, BindingResult
* SessionStatus
* @RequestBody
* @Value
* @Valid
#### 리턴 타입의 종류
##### 자동 추가 모델 모브젝트와 자동생성 뷰 이름
* @ModelAttribute 모델 오브젝트 또는 커맨드 오브젝트
* Map, Model, ModelMap 파라미터
* @ModelAttribute 메소드
* BindingResult
##### 메소드 리턴 타입 종류
* ModelAndView
* String
* void
* 모델 오브젝트
* Map/Model/ModelMap
* View
* @ResponseBody
#### @SessionAttributes와 SessionStatus
도메인 오브젝트를 사용해 **수정** 폼을 처리할 때 발생하는 문제들을 해결하는 방법
* 히든 필드
   * 브라우저 화면에는 보이지 않지만 HTML 소스를 열어보면 그 내용과 필드 이름까지 쉽게 알아낼 수 있어 보안에 심각한 문제를 일으킨다.
* DB 재조회(DB에서 조회 후 수정할 내용을 덮어 씌운 후 업데이트)
   * DB의 부담이 증가한다.
* 계층 사이의 강한 결합(수정할 필드들만을 위한 메소드와 계층을 준비)
   * 코드를 재사용하기가 힘들다.
> 위의 세 방법은 단점이 많다. 따라서 스프링의 해결책을 사용하자.
##### @SessionAttributes
* @SessionAttributes 애노테이션을 클래스 레벨에 부여하고 폼의 정보를 담을 모델 이름을 넣어준다.
   * 컨트롤러 메소드가 생성하는 모델 정보 중에서 @SessionAttributes에 지정한 이름과 동일한 것이 있다면 이를 세션에 저장해준다.
   * @ModelAttribute가 지정된 파라미터가 있을 때 이 파라미터에 전달해줄 오브젝트를 세션에서 가져온다.
* @SessionAttributes의 설정은 클래스의 모든 메소드에 적용된다.
##### SessionStatus
* @SessionAttributes를 사용할 때는 더 이상 필요 없는 세션 애트리뷰트를 코드로 제거해줘야 한다.
* 작업을 마무리하는 코드에서는 작업을 성공적으로 마쳤다면 SessionStatus 오브젝트의 setComplete() 메소드를 호출해서 세션에 저장해뒀던 오브젝트를 제거해줘야 한다.
##### 등록 폼을 위한 @SessionAttributes 사용
* 복잡한 도메인 오브젝트의 경우 미리 초기화 해두거나, 사용자의 입력을 돕기 위해 디폴트 값을 보여주는 경우, 초기화된 오브젝트를 세션에 저장해두고 사용해야 한다. 등록 폼의 입력 값에서도 잘못된 것이 있으면 다시 폼을 띄워서 재입력을 요구해야 한다.
* 등록과 수정 화면에 상관없이 폼을 출력할 때 폼의 내용을 담은 모델 오브젝트를 필요로 하기에, 스프링의 폼 태그를 사용하기 위해 @SessionAttributes를 이용해 모델 오브젝트를 저장했다가 다시 사용하는 게 좋다.
<hr/>

### 모델 바인딩과 검증

