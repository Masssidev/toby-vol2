# 데이터 액세스 기술
### 공통 개념
#### DAO 패턴
데이터 액세스 계층은 DAO 패턴이라 불리는 방식으로 분리하는 것이 원칙이다.

DAO 패턴은 DTO 또는 도메인 오브젝트만을 사용하는 인터페이스를 통해 데이터 엑세스 기술을 외부에 노출하지 않도록 만드는 것이다. 따라서 DAO는 구현 기술에 대한 정보를 외부에 공개해서는 안 된다. 이를 통해 DAO를 사용하는 코드에 영향을 주지 않고 데이터 액세스 기술을 변경하거나 하나 이상의 데이터 액세스 기술을 혼합해서 사용할 수 있게 해준다. 가장 중요한 장점은 DAO를 이용하는 서비스 계층의 코드를 기술이나 환경에 종속되지 않는 순수한 POJO로 개발할 수 있다는 것이다.
##### DAO 인터페이스와 DI
DAO는 인터페이스를 이용해 접근하고 DI 되도록 만들어야 한다. DAO 인터페이스에는 구체적인 데이터 액세스 기술과 관련된 어떤 API나 정보도 노출하지 않는다.
* 인터페이스를 만들 때 습관적으로 DAO 클래스의 모든 public 메소드를 추가하지 않아야 한다. DAO를 사용하는 서비스 계층 코드에서 의미 있는 메소드만 인터페이스로 공개해야 한다.
* 특정 데이터 액세스 기술에서만 의미 있는 DAO 메소드의 이름은 피한다.
##### 예외 처리
데이터 액세스 중에 발생하는 예외는 대부분 복구할 수 없다. 따라서 DAO 밖으로 던져질 때는 런타임 예외여야 한다.
* 의미 있는 예외를 처리할 때는 스프링에서 제공하는 예외 추상화를 사용한다.
* 데이터 액세스 기술의 API를 직접 사용할 때는 스프링에 내장된, AOP를 이용해 예외를 전환해준다.
#### 템플릿과 API
스프링은 DI의 응용 패턴인 템플릿/콜백 패턴을 이용해 데이터 액세스 기술을 위한 템플릿을 제공한다. 미리 만들어진 작업 흐름을 담은 템플릿은 반복되는 코드를 제거해줄 뿐 아니라 예외 변환과 트랜잭션 동기화 기능도 함께 제공해준다.
#### DataSource
Connection은 모든 데이터 액세스 기술에서 사용되는 필수 리소스다. 보통 미리 정해진 개수만큼의 DB 커넥션을 풀에 준비해두고, 애플리케이션이 요청할 때마다 풀에서 꺼내 하나씩 할당해주고 다시 돌려받아서 풀에 넣는 식의 풀링 기법을 이용한다.

스프링에서는 DataSource를 하나의 독립된 빈으로 등록하도록 강력하게 권장한다. 스프링 데이터 액세스 기술의 다양한 서비스에서 DataSource를 필요로 하고 있기 때문에 공유 가능한 스프링 빈으로 등록해줘야 한다.
* SimpleDriverDataSource
    * 스프링이 제공하는 가장 단순한 DataSource 구현 클래스다. getConnectioin()을 호출할 때마다 매번 DB 커넥션을 새로 마들고 따로 풀을 관리하지 않는다. 따라서 실전에서는 절대 사용하면 안 되고, 단순한 테스트용으로만 사용해야 한다.
* SingleConnectionDataSource
    * 하나의 물리적인 DB 커넥션만 만들어두고 이를 계속 사용하는 DataSource다. 순차적으로 진행되는 통합테스트에서는 사용 가능하지만 동시에 두 개 이상의 스레드가 동작하는 경우에는 하나의 커넥션을 공유하게 되므로 위험하다.
* 아파치 Commons DBCP
    * 가장 유명한 오픈소스 DB 커넥션 풀 라이브러리다.
* c3p0 JDBC/DataSource Resource Pool
    * c3p0는 JDBC 3.0 스펙을 준수하는 Connection과 Statement 풀을 제공하는 라이브러러리다.
* 상용 DB 커넥션 풀
    * 일부 상용 DB는 자체적으로 커넥션 풀 라이브러리를 제공해준다.
* JDNI/WAS DB 풀
    * 대부분의 자바 서버는 자체적으로 DB 풀 서비스를 제공해준다. DB 풀 라이브러리를 사용해 애플리케이션 레벨의 전용 풀을 만드는 대신 서버가 제공하는 DB 풀을 사용해야 하는 경우에는 JNDI를 통해 서버의 DataSource에 접근해야 한다. ```<jee:jndi-lookup>``` 태그를 이용하면 JNDI를 통해 가져온 오브젝트를 스프링의 빈으로 사용할 수 있다.
<hr/>

### JDBC
JDBC는 자바의 데이터 액세스 기술의 기본이 되는 로우레벨의 API다.
#### 스프링 JDBC 기술과 동작원리
##### 스프링의 JDBC 접근 방법
* SimpleJdbcTemplate
   * JdbcTemplate과 NameParameterJdbcTemplate에서 가장 많이 사용되는 기능을 통합하고 자바 5 이상의 장점을 최대한 활용할 수 있게 만든 것이다. 방대한 템플릿 메소드와 내장된 콜백을 제공하며, JDBC의 모든 기능을 최대한 활용할 수 있는 유연성을 갖고 있다.
* SimpleJdbcInsert, SimpleJdbcCall
   * DB가 제공해주는 메타정보를 활용해서 최소한의 코드만으로 단순한 JDBC 코드를 작성하게 해준다. 메타정보에서 컬럼 정보와 파라미터 정보를 가져와서 삽입용 SQL과 프로시저 호출 작업에 사용해주기 때문에 매우 편리하다.
##### 스프링 JDBC가 해주는 작업
* Connection 열기와 닫기
* Statement 준비와 닫기
* Statement 실행
* ResultSet 루프
* 예외처리와 변환
* 트랜잭션 처리
#### SimpleJdbcTemplate
SimpleJdbcTemplate이 제공하는 기능은 실행, 조회, 배치의 세 가지 작업으로 구분할 수 있다.
##### SimpleJdbcTemplate 생성
```SimpleJdbcTemplate template = new SimpleJdbcTemplate(dataSource);```<br/>
DataSource는 보통 빈으로 등록해두므로 SimpleJdbcTemplate이 필요한 DAO에서 DataSource 빈을 DI 받아 SimpleJdbcTemplate을 생성해두고 사용하면 된다.
##### SQL 파라미터
* 위치 치환자 - ```INSERT INTO MEMBER(ID, NAME, POINT) VALUES(?, ?, ?);```
* 이름 치환자 - ```INSERT INTO MEMBER(ID, NAME, POINT) VALUES(:id, :name, :point);```
> 이름을 이용해 바인딩해주기 때문에 중간에 순서가 바뀌어도 파라미터 바인딩에는 영향을 주지 않는다. 이름 치환자를 선호한다.

> 뿐만아니라 이름 치환자는 맵이나 오브젝트에 담긴 내용을 키 값이나 프로퍼티 이름을 이용해 바인딩할 수 있다.
##### SQL 실행 메소드
update() 메소드를 호출할 때 SQL과 함께 바인딩할 파라미터를 전달하는 방법
1. varargs
2. Map
3. SqlParameterSource
##### SQL 조회 메소드
* int queryForInt(String sql, [SQL 파라미터])<br/>
* long queryForLong(String sql, [SQL 파라미터])<br/>
* <T> T queryForObject(String sql, Class<T> requiredType, [SQL 파라미터])<br/>
* <T> T queryForObject(String sql, RowMapper<T> rm, [SQL 파라미터])<br/>
* <T> List<T> query(String sql, RowMapper<T> rm, [SQL 파라미터])<br/>
* Map<String, Object> queryForMap(String sql, [SQL 파라미터])<br/>
* List<Map<String, Object>> queryForList(String sql, [SQL 파라미터])
   
##### SQL 배치 메소드
SQL 배치 메소드는 update()로 실행하는 SQL들을 배치 모드로 실행하게 해준다. 내부적으로 JDBC Statement의 addBatch()와 executeBatch() 메소드를 이용해 여러 개의 SQL을 한 번에 처리한다. 많은 SQL을 실행해야 하는 경우 배치 방식을 사용하면 DB 호출을 최소화할 수 있기 때문에 성능이 향상될 수 있다.
* int[] batchUpdate(String sql, Map<String, ?>[] batchValues)
* int[] batchUpdate(String sql, SqlParameterSource[] batchArgs)
* int[] batchUpdate(String sql, List<Object[]> batchArgs)
#### SimpleJdbcInsert
##### SimpleJdbcInsert 생성
SimpleJdbcInsert는 테이블별로 만들어서 사용한다.<br/>
```SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(dataSource);```<br/>
SimpleJdbcInsert는 오브젝트를 생성한 후에 적어도 어떤 테이블을 적용할지 초기화해줘야 한다.
###### 초기화 메소드
* SimpleJcbcInsert with TableName(String tableName)
* SimpleJdbcInsert withSchemaName(String schemaName), <br/>SimpleJdbcInsert withCatalogName(String catalogName)
* SimpleJdbcInsert usingColumns(String... columnNames)
* SimpleJdbcInsert usingGeneratedKeyColumns(String... columnNames)
* SimpleJdbcInsertOperations withoutTableColumnMetaDataAccess()
##### SimpleJdbcInsert 실행
* int execute([이름 치환자 SQL 파라미터])<br/>
* Number executeAndReturnKey([이름 치환자 SQL 파라미터])
* keyHolder executeAndReturnKeyHolder([이름 치환자 SQL 파라미터])
#### SimpleJdbcCall
SimpleJdbcCall은 DB에 생성해둔 저장 프로시저 또는 저장 펑션을 호출할 때 사용한다.
##### SimpleJdbcCall 생성
SimpleJdbcCall은 dataSource를 이용해 생성한다. 멀티스레드 환경에 안전하게 공유 가능하므로 인스턴스 변수에 저장해두고 공유해서 사용해도 된다. 기본적으로 실행할 저장 프로시저나 저장 펑션 중의 하나로 초기화해줘야 한다.
###### 초기화 메소드
* SimpleJdbcCallOperations withProcedureName(String procedureName)
* SimpleJdbcCallOperations withFunctionName(String functionName)
* SimpleJdbcCallOperations resurninResultSet(String parameterName, ParameterizedRowMapper rowMapper)
##### SimpleJdbcCall실행
* <T> T executeFunction(Class<T> returnType, [SQL 파라미터])<br/>
* <T> T executeObject(Class<T> returnType, [SQL 파라미터])<br/>
* Map<String, Object> execute([SQL 파라미터])
   
#### 스프링 JDBC DAO
   
