# 테스트 컨텍스트 프레임워크
스프링의 POJO와 DI를 이용한 프로그래밍 모델이 가져온 가장 큰 혜택 중 하나는 바로 테스트다. POJO 프로그래밍 모델은 단위 테스트를 손쉽게 작성할 수 있는 
환경을 제공해주고, 기술에 종속적이지 않은 코드를 작성하게 해준다. IoC와 DI로 인해, 서버에 배치하지 않고도 스프링 컨테이너만으로 DB까지 참여하는 
이상적인 통합테스트가 가능해진다.
<hr/>

### 테스트 컨텍스트 프레임워크
스프링은 테스트에 사용되는 애플리케이션 컨텍스트를 생성하고 관리하고 테스트에 적용해주는 기능을 가진 테스트 프레임워크를 제공한다. 이를 테스트 컨텍스트 프레임워크라고 부른다. 테스트 컨텍스트 프레임워크는 스프링의 IoC/DI를 지원하는 애플리케이션 컨텍스트를 테스트에서 효과적으로 사용하게 해준다. 테스트 컨텍스트 프레임워크를 이용하면, 서버에서와 거의 동일한 구성으로 동작하는 통합 테스트를 손쉽게 만들 수 있다.
#### 테스트 프레임워크와 컨텍스트 테스트
자바에서 가장 많이 사용되는 테스트 프레임워크로는 JUnit과 TestNG가 있다. JUnit은 기존의 JUnit 3와 애노테이션 방식으로 새롭게 만들어진 JUnit 4로 다시 구분할 수 있다. 스프링 컨텍스트 테스트는 이 세 가지 테스트 프레임워크를 모두 지원한다. 
##### 테스트용 애플리케이션 컨텍스트 캐싱과 설정파일
* JUnit 4에서는 특정 클래스를 상속하지 않아도 테스트 코드를 작성할 수 있다. 테스트 메소드에 @Test라는 애노테이션만 붙여주면 메소드가 속한 클래스는 테스트 클래스가 되며, @Test가 붙은 모든 메소드가 각각 하나의 독립적인 테스트가 된다.
* 테스트가 독립적이라고 해서 매번 스프링 컨텍스트, 즉 컨테이너를 새로 만드는 건 매우 비효율적인 방법이기에, 스프링은 테스트가 사용하는 컨텍스트를 캐싱해서 여러 테스트에서 하나의 컨텍스트를 공유할 수 있는 방법을 제공한다. 동일한 컨텍스트 구성을 갖는 테스트끼리는 같은 컨텍스트를 공유하는 것이다.
* 테스트 컨텍스트 프레임워크가 적용된 테스트 예
```
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("/test-applicationContext")
public class Test1 {
  @Test public void testMethod1() {...}
  @Test public void testMethod2() {...}
}
```
##### 컨텍스트 설정의 상속과 컨텍스트 로더
* JUnit 4의 장점은 테스트 클래스가 특정 클래스를 상속하도록 강제하지 않는다는 것이다. 따라서 테스트 클래스를 구성할 때 필요하면 상속구조를 활용할 수도 있다. 슈퍼클래스와 서브클래스에서 모두 @ContextConfiguration을 이용해 컨텍스트 파일을 지정했다면 컨텍스트 파일 정보는 상속된다. 따라서 서브클래스의 컨텍스트 파일 정보는 슈퍼클래스에서 정의된 것까지 포함된다. 슈퍼클래스의 컨텍스트 파일 설정을 무시하고 새롭게 정의하고 싶다면 @ContextConfiguration의 inheritLocations를 false로 바꿔주면 된다.
* 테스트 컨텍스트를 로딩하는 방식을 변경하려면 ContextLoader 인터페이스를 구현한 클래스를 만들고 이를 @ContextConfiguration의 loader 엘리먼트에 지정해주면 된다.
#### 테스트 코드의 테스트 컨텍스트 활용
'테스트 컨텍스트 프레임워크'의 '컨텍스트'는 애플리케이션 컨텍스트가 아니다. 테스트에서 사용되는 애플리케이션 컨텍스트를 생성하고 관리해주는 오브젝트를 가리키는 용어다. 
##### 테스트 컨텍스트로부터 DI 받기
테스트 클래스는 테스트 컨텍스트로부터 애플리케이션 컨텍스트와 그에 담긴 빈을 제공받아 테스트 코드에서 사용한다. 애플리케이션 컨텍스트를 제공받는 방법은 스프링답게 DI를 사용한다. ```@Autowired ApplicationContext context;``` 애플리케이션 컨텍스트 외에도 모든 컨텍스트 내의 원하는 빈을 제공받을 수 있다.
##### 공유 컨텍스트 사용 시 주의할 점
* 캐싱 기법을 통해 하나의 컨텍스트를 여러 테스트가 공유할 수 있다는 건 테스트 컨텍스트 프레임워크의 장점이지만, 단점도 있다. 컨텍스트를 공유하는 테스트 메소드는 컨텍스트가 자신이 독점하는 것이 아니므로 그 구성이나 내부 정보를 함부로 변경해서는 안 된다.
* 테스트는 모두 고립돼서 동작해야 하고 테스트 결과도 자신이 검증하는 코드가 바뀌지 않는 한 항상 일정해야 한다.
> @DirtiesContext 애노테이션이 붙은 테스트가 수행되고 나면 스프링은 현 테스트 컨텍스트를 강제로 제거한다. 이후에 설정파일이 같은 컨텍스트를 사용하는 테스트가 진행된다면, 이때는 새로운 컨텍스트가 만들어진다. 따라서 다른 테스트에는 영향을 주지 않고 안전하게 컨텍스트를 조작하는 테스트를 만들 수 있다.
<hr/>

### 트랜잭션 지원 테스트
